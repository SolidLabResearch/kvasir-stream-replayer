import { KvasirClient } from './kvasir-client';
import { TimeseriesDataPoint } from './types';

export interface LatencySample {
  sensorId: string;
  generatedAt: Date;
  receivedAt: Date;
  latencyMs: number;
}

export interface PollingLatencyBenchmarkConfig {
  kvasirUrl: string;
  sensorIds: string[];
  testDuration: number; // seconds
  eventInterval: number; // milliseconds between events
  maxLatencySamples: number;
  pollingInterval: number; // milliseconds between polls
}

export class PollingLatencyBenchmark {
  private client: KvasirClient;
  private config: PollingLatencyBenchmarkConfig;
  private latencySamples: LatencySample[] = [];
  private eventGenerationTimer?: NodeJS.Timeout;
  private pollingSubscription?: { unsubscribe: () => void };
  private pendingEvents = new Map<string, { sensorId: string; generatedAt: Date }>();

  constructor(kvasirClient: KvasirClient, config: Partial<PollingLatencyBenchmarkConfig> = {}) {
    this.client = kvasirClient;
    this.config = {
      kvasirUrl: 'http://localhost:8080',
      sensorIds: ['sensor1', 'sensor2', 'sensor3'],
      testDuration: 60, // 1 minute
      eventInterval: 1000, // 1 second
      maxLatencySamples: 1000,
      pollingInterval: 500, // Poll every 500ms
      ...config
    };
  }

  /**
   * Run polling latency benchmark
   */
  async runBenchmark(): Promise<{
    samples: LatencySample[];
    summary: {
      totalSamples: number;
      averageLatency: number;
      minLatency: number;
      maxLatency: number;
      p95Latency: number;
      p99Latency: number;
    };
  }> {
    console.log('Starting Polling Latency Benchmark');
    console.log(`Testing ${this.config.sensorIds.length} sensors for ${this.config.testDuration}s`);
    console.log(`â±ï¸  Event interval: ${this.config.eventInterval}ms`);
    console.log(`Polling interval: ${this.config.pollingInterval}ms`);
    console.log(`Max samples: ${this.config.maxLatencySamples}`);
    console.log('');

    this.latencySamples = [];
    this.pendingEvents.clear();

    // Start polling for new measurements
    this.startPolling();

    // Start generating events
    this.startEventGeneration();

    // Wait for test duration
    await this.waitForDuration(this.config.testDuration * 1000);

    // Cleanup
    this.stopBenchmark();

    // Calculate results
    const summary = this.calculateSummary();

    console.log('\nBenchmark Results:');
    console.log(`Total samples: ${summary.totalSamples}`);
    console.log(`Average latency: ${summary.averageLatency.toFixed(2)}ms`);
    console.log(`Min latency: ${summary.minLatency.toFixed(2)}ms`);
    console.log(`Max latency: ${summary.maxLatency.toFixed(2)}ms`);
    console.log(`95th percentile: ${summary.p95Latency.toFixed(2)}ms`);
    console.log(`99th percentile: ${summary.p99Latency.toFixed(2)}ms`);

    return {
      samples: this.latencySamples,
      summary
    };
  }

  private startPolling(): void {
    console.log('Starting polling subscription for measurements...');

    this.pollingSubscription = this.client.subscribeToAllMeasurementsPolling(
      (measurement) => {
        console.log('ðŸ“¨ Received measurement via polling:', measurement);
        const eventId = `${measurement.sensorId}-${measurement.timestamp}`;

        // Check if this measurement was generated by us
        const generated = this.pendingEvents.get(eventId);
        if (generated) {
          const receivedAt = new Date();
          const latencyMs = receivedAt.getTime() - generated.generatedAt.getTime();

          this.latencySamples.push({
            sensorId: measurement.sensorId!,
            generatedAt: generated.generatedAt,
            receivedAt,
            latencyMs
          });

          this.pendingEvents.delete(eventId);

          if (this.latencySamples.length % 5 === 0) {
            console.log(`Collected ${this.latencySamples.length} latency samples`);
          }

          // Stop if we have enough samples
          if (this.latencySamples.length >= this.config.maxLatencySamples) {
            console.log('Reached maximum sample count, stopping early...');
            this.stopBenchmark();
          }
        } else {
          console.log('âš ï¸  Received measurement not in pending events:', eventId);
        }
      },
      {
        pollingInterval: this.config.pollingInterval
      }
    );
  }

  private startEventGeneration(): void {
    console.log('ðŸ”„ Starting event generation...');

    let eventCount = 0;
    const startTime = Date.now();

    this.eventGenerationTimer = setInterval(async () => {
      const elapsed = Date.now() - startTime;
      if (elapsed >= this.config.testDuration * 1000) {
        this.stopEventGeneration();
        return;
      }

      // Generate events for all sensors
      for (const sensorId of this.config.sensorIds) {
        const generatedAt = new Date();
        const value = Math.random() * 100;

        try {
          // Create TimeseriesDataPoint for insertion
          const dataPoint: TimeseriesDataPoint = {
            id: `measurement-${sensorId}-${generatedAt.getTime()}`,
            timestamp: generatedAt,
            value: value,
            valueType: 'number',
            sensorId: sensorId,
            propertyType: 'test-value'
          };

          // Insert measurement into Kvasir
          await this.client.insertBatch([dataPoint]);

          // Track for latency measurement
          const eventId = `${sensorId}-${generatedAt.toISOString()}`;
          this.pendingEvents.set(eventId, {
            sensorId,
            generatedAt
          });

          eventCount++;
          if (eventCount % 10 === 0) {
            console.log(`ðŸ“¤ Generated ${eventCount} events (${this.pendingEvents.size} pending)`);
          }
        } catch (error) {
          console.error(`Failed to insert measurement for ${sensorId}:`, error);
        }
      }
    }, this.config.eventInterval);
  }

  private async waitForDuration(durationMs: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, durationMs));
  }

  private stopBenchmark(): void {
    this.stopEventGeneration();
    if (this.pollingSubscription) {
      this.pollingSubscription.unsubscribe();
    }
  }

  private stopEventGeneration(): void {
    if (this.eventGenerationTimer) {
      clearInterval(this.eventGenerationTimer);
      this.eventGenerationTimer = undefined;
    }
  }

  private calculateSummary() {
    if (this.latencySamples.length === 0) {
      return {
        totalSamples: 0,
        averageLatency: 0,
        minLatency: 0,
        maxLatency: 0,
        p95Latency: 0,
        p99Latency: 0
      };
    }

    const latencies = this.latencySamples.map(s => s.latencyMs).sort((a, b) => a - b);

    return {
      totalSamples: this.latencySamples.length,
      averageLatency: latencies.reduce((sum, lat) => sum + lat, 0) / latencies.length,
      minLatency: latencies[0],
      maxLatency: latencies[latencies.length - 1],
      p95Latency: latencies[Math.floor(latencies.length * 0.95)] || latencies[latencies.length - 1],
      p99Latency: latencies[Math.floor(latencies.length * 0.99)] || latencies[latencies.length - 1]
    };
  }
}